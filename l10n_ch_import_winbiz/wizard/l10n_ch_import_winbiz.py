# -*- coding: utf-8 -*-
##############################################################################
#
#    Author Vincent Renaville
#    Copyright 2015 Camptocamp SA
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
##############################################################################

import sys
import traceback
import logging
import base64
from lxml import etree
import tempfile
from itertools import izip_longest
from StringIO import StringIO
from openerp import models, fields, api


_logger = logging.getLogger(__name__)


class AccountWinbizImport(models.TransientModel):
    _name = 'account.winbiz.import'
    _description = 'Import Accounting Winbiz'
    _rec_name = 'state'

    company_id = fields.Many2one('res.company', 'Company',
                                 invisible=True)
    report = fields.Text(
        'Report',
        readonly=True
        )
    journal_id = fields.Many2one('account.journal', 'Journal',
                                 required=True)
    state = fields.Char(sting="Import state"
                        'Report',
                        readonly=True,
                        default="draft"
                        )
    file = fields.Binary(
        'File',
        required=True
        )
    imported_move_ids = fields.Many2many(
        'account.move', 'import_cresus_move_rel',
        string='Imported moves')

    help_html = fields.Html('Import help', readonly=True,
                            default='''
                 In order to import your 'Winbiz Salaires' .xml \
                 file you must complete the following requirements : \
                <ul>
                <li> The accounts, analytical accounts used in the Cresus\
                 file must be previously created into Odoo  </li>
                </ul>''')

    HEAD_ODOO = ['ref', 'date', 'journal_id',
                 'line_ids/account_id', 'line_ids/partner_id', 'line_ids/name',
                 'line_ids/debit', 'line_ids/credit',
                 'line_ids/tax_line_id',
                 'line_ids/analytic_account_id']

    @api.multi
    def open_account_moves(self):
        res = {
            'domain': str([('id', 'in', self.imported_move_ids.ids)]),
            'name': 'Account Move',
            'view_type': 'form',
            'view_mode': 'tree,form',
            'res_model': 'account.move',
            'view_id': False,
            'type': 'ir.actions.act_window',
        }
        return res

    def format_messages(self, messages):
        """Format error messages generated by the BaseModel.load method

        :param messages: return of BaseModel.load messages key
        :returns: formatted string

        """
        res = []
        for msg in messages:
            rows = msg.get('rows', {})
            res.append("%s. -- Field: %s -- rows %s to %s" % (
                msg.get('message', 'N/A'),
                msg.get('field', 'N/A'),
                rows.get('from', 'N/A'),
                rows.get('to', 'N/A'))
            )
        return "\n \n".join(res)

    def _parse_xml(self):
        """Parse stored XML file in order to be usable by BaseModel.load method.

        Manage base 64 decoding.

        :param imp_id: current importer id
        :returns: (head [list of first row], data [list of list])

        """
        # We use tempfile in order to avoid memory error with large files
        with tempfile.TemporaryFile() as src:
            content = self.file
            src.write(content)
            decoded = tempfile.TemporaryFile()
            src.seek(0)
            base64.decode(src, decoded)
            decoded.seek(0)
            return etree.iterparse(decoded, tag="ecritures")

    def _manage_load_results(self, result):
        """Manage the BaseModel.load function output and store exception.

        Will generate success/failure report and store it into report field.
        Manage commit and rollback even if load method uses PostgreSQL
        Savepoints.

        :param result: BaseModel.load returns
                       {ids: list(int)|False, messages: [Message]}
        """
        # Import sucessful
        if not result['messages']:
            self.write({'state': 'done',
                        'report': "Lines imported",
                        'imported_move_ids': [(6, 0, result['ids'])]})
        else:
            self.write({'report': self.format_messages(result['messages']),
                        'state': 'error'})

    @api.multi
    def _standardise_data(self, data):
        """ This function split one line of the XML into multiple lines.
        Winbiz just writes one line per move.
        """
        new_openerp_data = []
        cp = self.env.user.company_id
        company_partner = cp.partner_id.name
        standard_dict = dict(izip_longest(self.HEAD_ODOO, []))
        counterpart = False
        for action_winbiz, elem_winbiz in data:
            winbiz_item = {subelem.tag: subelem.text for subelem in elem_winbiz.getchildren()}
            if counterpart and counterpart['ref'] != winbiz_item[u'pièce']:
                if counterpart['line_ids/debit'] > counterpart['line_ids/credit']:
                    counterpart['line_ids/debit'] -= counterpart['line_ids/credit']
                    counterpart['line_ids/credit'] = 0.0
                else:
                    counterpart['line_ids/credit'] -= counterpart['line_ids/debit']
                    counterpart['line_ids/debit'] = 0.0
                counterpart = False
                # it's already in new_openerp_data
            default_value = standard_dict.copy()
            if winbiz_item['multiple'] == 'false':
                default_value.update({'date': winbiz_item['date'],
                                      'ref': winbiz_item[u'pièce'],
                                      'journal_id': self.journal_id.name})
                default_value.update({'line_ids/partner_id': company_partner,
                                      'line_ids/name': winbiz_item[u'libellé'],
                                      'line_ids/debit': winbiz_item['montant'],
                                      'line_ids/credit': 0.0,
                                      'line_ids/account_id':
                                          winbiz_item[u'cpt_débit']})
                new_openerp_data.append(default_value)
                inverted_default_value = default_value.copy()
                inverted_default_value.update({'date': None,
                                               'ref': None,
                                               'journal_id': None})
                inverted_default_value.update({'line_ids/partner_id': company_partner,
                                               'line_ids/name': winbiz_item[u'libellé'],
                                               'line_ids/debit': 0.0,
                                               'line_ids/credit': winbiz_item['montant'],
                                               'line_ids/account_id':
                                                   winbiz_item[u'cpt_crédit']})
                new_openerp_data.append(inverted_default_value)
            elif not counterpart:
                default_value.update({'date': winbiz_item['date'],
                                      'ref': winbiz_item[u'pièce'],
                                      'journal_id': self.journal_id.name})
                #reverse_counterpart = (cpt_débit == 'Multiple')
                default_value.update({'line_ids/partner_id': company_partner,
                                      'line_ids/name': winbiz_item[u'libellé'],
                                      'line_ids/debit': 0.0,
                                      'line_ids/credit': 0.0,
                                      'line_ids/account_id':
                                          winbiz_item[u'cpt_débit']})
                counterpart = default_value # keep mutating: amounts can only be deduced from following lines
                new_openerp_data.append(default_value)
            else:
                default_value.update({'line_ids/partner_id': company_partner,
                                      'line_ids/name': winbiz_item[u'libellé'],
                                      'line_ids/debit': 0.0,
                                      'line_ids/credit': 0.0})
                if counterpart['line_ids/account_id'] == winbiz_item[u'cpt_débit']:
                    counterpart['line_ids/debit'] += float(winbiz_item['montant'])
                    default_value['line_ids/credit'] = float(winbiz_item['montant'])
                    default_value['line_ids/account_id'] = winbiz_item[u'cpt_crédit']
                else:
                    counterpart['line_ids/credit'] += float(winbiz_item['montant'])
                    default_value['line_ids/debit'] = float(winbiz_item['montant'])
                    default_value['line_ids/account_id'] = winbiz_item[u'cpt_débit']
                new_openerp_data.append(default_value)
        return new_openerp_data

    @api.multi
    def _load_data(self, data):
        """Function that does the load of parsed CSV file.

        It will log exception and susccess into the report fields.

        :param data: CSV file content (list of data list)
        """
        # Change data from dict to list of array
        data_array = []
        error_report = ''
        status_report = False
        for data_item_dict in data:
            data_item = []
            for item in self.HEAD_ODOO:
                data_item.append(data_item_dict[item])
            data_array.append(data_item)

        try:
            res = self.env['account.move'].load(self.HEAD_ODOO, data_array)
            self._manage_load_results(res)
        except Exception as exc:
            ex_type, sys_exc, tb = sys.exc_info()
            tb_msg = ''.join(traceback.format_tb(tb, 30))
            _logger.error(tb_msg)
            _logger.error(repr(exc))
            error_report += "Unexpected exception.\n %s \n %s \n" % \
                (repr(exc), tb_msg)
            status_report = 'error'
        if status_report == 'error':
            self.write({'state': status_report,
                        'report': error_report})
        return {
            'name': 'Winbiz move line importer',
            'type': 'ir.actions.act_window',
            'res_model': 'account.winbiz.import',
            'view_type': 'form',
            'view_mode': 'form,tree',
            'res_id': self.id,
            'nodestroy': False,
            'target': 'new',
        }

    @api.multi
    def import_file(self):
        data = self._parse_xml()
        new_data = self._standardise_data(data)
        return self._load_data(new_data)
